<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逝殇_Vizard...</title>
  <subtitle>我以为人生很漫长,匆匆翻看,却再也无法逆转</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-19T11:59:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>_Vizard战国</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 导航栏属性 透明属性translucent 偏移64 滑动视图内容自动向下偏移的问题总结</title>
    <link href="http://yoursite.com/2017/05/19/iOS-%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%B1%9E%E6%80%A7-%E9%80%8F%E6%98%8E%E5%B1%9E%E6%80%A7translucent-%E5%81%8F%E7%A7%BB64-%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%86%85%E5%AE%B9%E8%87%AA%E5%8A%A8%E5%90%91%E4%B8%8B%E5%81%8F%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/19/iOS-导航栏属性-透明属性translucent-偏移64-滑动视图内容自动向下偏移的问题总结/</id>
    <published>2017-05-19T11:55:12.000Z</published>
    <updated>2017-05-19T11:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="translucent属性"><a href="#translucent属性" class="headerlink" title="translucent属性:"></a>translucent属性:</h4><p>百度翻译:半透明的,透亮的,有光泽的;<br>该属性控制的是导航栏的半透明属性,直接影响到的是视图控制器中视图的frame中0点的位置</p>
<p>如果设置如下:<br>(1)</p>
<pre><code>self.navigationController.navigationBar.translucent = NO;

self.view.bounds.size.height 变为原高度 - 64;
</code></pre><p>如果表视图的尺寸设置为屏幕大小的话,在 IOS7以上的系统中,默认使用 屏幕尺寸为原来大小 即给表视图设置了667的高度,会因为这个属性而偏移到屏幕外面:</p>
<p>如果在这种情况下,给导航栏设置背景图片,透明图片(没有影响),如果给导航栏设置一张非透明的背景图片(被平铺),如果给导航栏设置背景颜色(无效);</p>
<p>在</p>
<pre><code>self.navigationController.navigationBar.translucent = NO;的前提下,如果想要视图的0点还是有屏幕左上角开始 而不是从(0,64)开始,那么就需要做的的就是设置另外一个属性
</code></pre><p>如果设置如下:<br>(2)</p>
<pre><code>self.navigationController.navigationBar.translucent = YES;

self.view.bounds.size.height 变为原高度 - 64;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;translucent属性&quot;&gt;&lt;a href=&quot;#translucent属性&quot; class=&quot;headerlink&quot; title=&quot;translucent属性:&quot;&gt;&lt;/a&gt;translucent属性:&lt;/h4&gt;&lt;p&gt;百度翻译:半透明的,透亮的,有光泽的;&lt;br&gt;该
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>unrecognized selector的异常</title>
    <link href="http://yoursite.com/2017/05/18/unrecognized-selector%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/05/18/unrecognized-selector的异常/</id>
    <published>2017-05-18T13:20:30.000Z</published>
    <updated>2017-05-19T12:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](http://ww3.sinaimg.cn/large/006tKfTcgy1ffpty74nmdj30pw0hejuk.jpg) -->
<h3 id="unrecognized-selector的异常之前的三次拯救"><a href="#unrecognized-selector的异常之前的三次拯救" class="headerlink" title="unrecognized selector的异常之前的三次拯救:"></a>unrecognized selector的异常之前的三次拯救:</h3><h4 id="1-Method-resolution"><a href="#1-Method-resolution" class="headerlink" title="1. Method resolution"></a>1. Method resolution</h4><p>objc运行时会调用+resolveInstanceMethod:或者<br> +resolveClassMethod:，让你有机会提供一个函数实现。<br> 如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，<br> 否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>
<h4 id="2-Fast-forwarding"><a href="#2-Fast-forwarding" class="headerlink" title="2. Fast forwarding"></a>2. Fast forwarding</h4><p>如果目标对象实现了-forwardingTargetForSelector:，<br>Runtime 这时就会调用这个方法，<br>给你把这个消息转发给其他对象的机会。<br> 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，<br> 当然发送的对象会变成你返回的那个对象。<br> 否则，就会继续Normal Fowarding。<br>  这里叫Fast，只是为了区别下一步的转发机制。<br>  因为这一步不会创建任何新的对象，<br>  但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>
<h4 id="3-Normal-forwarding"><a href="#3-Normal-forwarding" class="headerlink" title="3. Normal forwarding"></a>3. Normal forwarding</h4><p>这一步是Runtime最后一次给你挽救的机会。<br>首先它会发送-methodSignatureForSelector:<br>消息获得函数的参数和返回值类型。<br>如果-methodSignatureForSelector:返回nil，<br>Runtime则会发出-doesNotRecognizeSelector:<br>消息，程序这时也就挂掉了。<br>如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- ![](http://ww3.sinaimg.cn/large/006tKfTcgy1ffpty74nmdj30pw0hejuk.jpg) --&gt;
&lt;h3 id=&quot;unrecognized-selector的异常之前的三次拯救&quot;&gt;&lt;a href=&quot;#unrecogniz
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>玩转GCD-主要讲如何用</title>
    <link href="http://yoursite.com/2017/05/17/DispatchPlay/"/>
    <id>http://yoursite.com/2017/05/17/DispatchPlay/</id>
    <published>2017-05-17T12:38:49.000Z</published>
    <updated>2017-05-19T12:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](http://ww2.sinaimg.cn/large/006tNbRwgy1ffon7ij0bjj30pw12an0e.jpg) -->
<h3 id="与其说CGD是线程管理，不如说是队列管理，那么我们先来介绍一下GCD中常用的队列："><a href="#与其说CGD是线程管理，不如说是队列管理，那么我们先来介绍一下GCD中常用的队列：" class="headerlink" title="与其说CGD是线程管理，不如说是队列管理，那么我们先来介绍一下GCD中常用的队列："></a>与其说CGD是线程管理，不如说是队列管理，那么我们先来介绍一下GCD中常用的队列：</h3><h4 id="Serial-Diapatch-Queue-串行队列"><a href="#Serial-Diapatch-Queue-串行队列" class="headerlink" title="Serial Diapatch Queue 串行队列"></a>Serial Diapatch Queue 串行队列</h4><p>当任务相互依赖，具有明显的先后顺序的时候，使用串行队列是一个不错的选择 创建一个串行队列：</p>
<pre><code>dispatch_queue_t serialDispatchQueue=dispatch_queue_create(&quot;com.test.queue&quot;, DISPATCH_QUEUE_SERIAL);
</code></pre><h4 id="第一个参数为队列名，第二个参数为队列类型，当然，第二个参数如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列："><a href="#第一个参数为队列名，第二个参数为队列类型，当然，第二个参数如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列：" class="headerlink" title="第一个参数为队列名，第二个参数为队列类型，当然，第二个参数如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列："></a>第一个参数为队列名，第二个参数为队列类型，当然，第二个参数如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列：</h4><pre><code>dispatch_async(serialDispatchQueue, ^{
NSLog(@&quot;1&quot;);
});

dispatch_async(serialDispatchQueue, ^{
sleep(2);
NSLog(@&quot;2&quot;);
});

dispatch_async(serialDispatchQueue, ^{
sleep(1);
NSLog(@&quot;3&quot;);
});
</code></pre><h5 id="日志的log"><a href="#日志的log" class="headerlink" title="日志的log:"></a>日志的log:</h5><pre><code>2016-03-07 10:17:13.907 GCD[2195:61497] 1
2016-03-07 10:17:15.911 GCD[2195:61497] 2
2016-03-07 10:17:16.912 GCD[2195:61497] 3
</code></pre><p>没错，他在61497这个编号的线程中做了串行输出，相互彼此依赖，串行执行</p>
<h4 id="Concurrent-Diapatch-Queue-并发队列"><a href="#Concurrent-Diapatch-Queue-并发队列" class="headerlink" title="Concurrent Diapatch Queue 并发队列"></a>Concurrent Diapatch Queue 并发队列</h4><p>与串行队列刚好相反，他不会存在任务间的相互依赖。<br>创建一个并发队列：</p>
<pre><code>dispatch_queue_t concurrentDispatchQueue=dispatch_queue_create(&quot;com.test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre><h5 id="比较2个队列的创建，我们发现只有第二个参数从DISPATCH-QUEUE-SERIAL变成了对应的DISPATCH-QUEUE-CONCURRENT，其他完全一样。用同一段代码，换一种队列我们来比较一下效果："><a href="#比较2个队列的创建，我们发现只有第二个参数从DISPATCH-QUEUE-SERIAL变成了对应的DISPATCH-QUEUE-CONCURRENT，其他完全一样。用同一段代码，换一种队列我们来比较一下效果：" class="headerlink" title="比较2个队列的创建，我们发现只有第二个参数从DISPATCH_QUEUE_SERIAL变成了对应的DISPATCH_QUEUE_CONCURRENT，其他完全一样。用同一段代码，换一种队列我们来比较一下效果："></a>比较2个队列的创建，我们发现只有第二个参数从DISPATCH_QUEUE_SERIAL变成了对应的DISPATCH_QUEUE_CONCURRENT，其他完全一样。用同一段代码，换一种队列我们来比较一下效果：</h5><pre><code>dispatch_async(concurrentDispatchQueue, ^{
NSLog(@&quot;1&quot;);
});
dispatch_async(concurrentDispatchQueue, ^{
sleep(2);
NSLog(@&quot;2&quot;);
});
dispatch_async(concurrentDispatchQueue, ^{
sleep(1);
NSLog(@&quot;3&quot;);
});
</code></pre><h5 id="输出的log："><a href="#输出的log：" class="headerlink" title="输出的log："></a>输出的log：</h5><pre><code>2016-03-07 10:42:38.289 GCD[2260:72557] 1
2016-03-07 10:42:39.291 GCD[2260:72559] 3
2016-03-07 10:42:40.293 GCD[2260:72556] 2
</code></pre><h5 id="我们发现，log的输出在3个不同编号的线程中进行，而且相互不依赖，不阻塞。"><a href="#我们发现，log的输出在3个不同编号的线程中进行，而且相互不依赖，不阻塞。" class="headerlink" title="我们发现，log的输出在3个不同编号的线程中进行，而且相互不依赖，不阻塞。"></a>我们发现，log的输出在3个不同编号的线程中进行，而且相互不依赖，不阻塞。</h5><h4 id="Global-Queue-amp-Main-Queue"><a href="#Global-Queue-amp-Main-Queue" class="headerlink" title="Global Queue &amp; Main Queue"></a>Global Queue &amp; Main Queue</h4><p>这是系统为我们准备的2个队列：</p>
<pre><code>● Global Queue其实就是系统创建的Concurrent Diapatch Queue
● Main Queue 其实就是系统创建的位于主线程的Serial Diapatch Queue
</code></pre><p>通常情况我们会把这2个队列放在一起使用，也是我们最常用的开异步线程-执行异步任务-回主线程的一种方式：</p>
<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
NSLog(@&quot;异步线程&quot;);
dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;异步主线程&quot;);
});
});
</code></pre><p>通过上面的代码我们发现了2个有意思的点：</p>
<pre><code>● dispatch_get_global_queue存在优先级，没错，他一共有4个优先级：
#define DISPATCH_QUEUE_PRIORITY_HIGH 2
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0
#define DISPATCH_QUEUE_PRIORITY_LOW (-2)
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
NSLog(@&quot;4&quot;);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
NSLog(@&quot;3&quot;);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
NSLog(@&quot;2&quot;);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
NSLog(@&quot;1&quot;);
});
</code></pre><p>在指定优先级之后，同一个队列会按照这个优先级执行，打印的顺序为1、2、3、4，当然这不是串行队列，所以不存在绝对回调先后。<br>  ● 异步主线程<br>  ○ 在日常工作中，除了在其他线程返回主线程的时候需要用这个方法，还有一些时候我们在主线程中直接调用异步主线程，这是利用dispatch_async的特性：block中的任务会放在主线程本次runloop之后返回。这样，有些存在先后顺序的问题就可以得到解决了。<br>说完了队列，我们再说说GCD提供的一些操作队列的方法</p>
<h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><p>刚刚我们说了系统的Global Queue是可以指定优先级的，那我们如何给自己创建的队列执行优先级呢？这里我们就可以用到dispatch_set_target_queue这个方法</p>
<pre><code>dispatch_queue_t serialDispatchQueue=dispatch_queue_create(&quot;com.test.queue&quot;, NULL);
dispatch_queue_t dispatchgetglobalqueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
dispatch_set_target_queue(serialDispatchQueue, dispatchgetglobalqueue);
dispatch_async(serialDispatchQueue, ^{
NSLog(@&quot;我优先级低，先让让&quot;);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
NSLog(@&quot;我优先级高,我先block&quot;);
});
</code></pre><p>我把自己创建的队列塞到了系统提供的global_queue队列中，我们可以理解为：我们自己创建的queue其实是位于global_queue中执行,所以改变global_queue的优先级，也就改变了我们自己所创建的queue的优先级。所以我们常用这种方式来管理子队列。<br>dispatch_after<br>这个是最常用的，用来延迟执行的GCD方法，因为在主线程中我们不能用sleep来延迟方法的调用，所以用它是最合适的，我们做一个简单的例子：<br>NSLog(@”小破孩-波波1”);</p>
<pre><code>double delayInSeconds = 2.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
NSLog(@&quot;小破孩-波波2&quot;);
});
----
2016-03-07 11:25:06.019 GCD[2443:95722] 小破孩-波波1
2016-03-07 11:25:08.019 GCD[2443:95722] 小破孩-波波2
</code></pre><p>我们看到他就是在主线程，就是刚好延迟了2秒，当然，我说这个2秒并不是绝对的，为什么这么说？还记得我之前在介绍dispatch_async这个特性的时候提到的吗？他的block中方法的执行会放在主线程runloop之后，所以，如果此时runloop周期较长的时候，可能会有一些时差产生。<br>dispatch_group<br>当我们需要监听一个并发队列中，所有任务都完成了，就可以用到这个group，因为并发队列你并不知道哪一个是最后执行的，所以以单独一个任务是无法监听到这个点的，如果把这些单任务都放到同一个group，那么，我们就能通过dispatch_group_notify方法知道什么时候这些任务全部执行完成了。</p>
<pre><code>dispatch_queue_t queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group=dispatch_group_create();
dispatch_group_async(group, queue, ^{NSLog(@&quot;0&quot;);});
dispatch_group_async(group, queue, ^{NSLog(@&quot;1&quot;);});
dispatch_group_async(group, queue, ^{NSLog(@&quot;2&quot;);});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{NSLog(@&quot;down&quot;);});
</code></pre><p>在例子中，我把3个log分别放在并发队列中，通过把这个并发队列任务统一加入group中，group每次runloop的时候都会调用一个方法dispatch_group_wait(group, DISPATCH_TIME_NOW)，用来检查group中的任务是否已经完成，如果已经完成了，那么会执行dispatch_group_notify的block，输出’down’看一下运行结果：</p>
<pre><code>2016-03-07 14:21:58.647 GCD[9424:156388] 2
2016-03-07 14:21:58.647 GCD[9424:156382] 0
2016-03-07 14:21:58.647 GCD[9424:156385] 1
2016-03-07 14:21:58.650 GCD[9424:156324] down
</code></pre><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>此方法的作用是在并发队列中，完成在它之前提交到队列中的任务后打断，单独执行其block，并在执行完成之后才能继续执行在他之后提交到队列中的任务：</p>
<pre><code>dispatch_queue_t concurrentDispatchQueue=dispatch_queue_create(&quot;com.test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;0&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;1&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;2&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;3&quot;);});
dispatch_barrier_async(concurrentDispatchQueue, ^{sleep(1); NSLog(@&quot;4&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;5&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;6&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;7&quot;);});
dispatch_async(concurrentDispatchQueue, ^{NSLog(@&quot;8&quot;);});
</code></pre><p>输出的结果为：<br>2016-03-07 14:45:32.410 GCD[10079:169655] 1<br>2016-03-07 14:45:32.410 GCD[10079:169658] 2<br>2016-03-07 14:45:32.410 GCD[10079:169656] 0<br>2016-03-07 14:45:32.410 GCD[10079:169661] 3<br>2016-03-07 14:45:33.414 GCD[10079:169661] 4<br>2016-03-07 14:45:33.415 GCD[10079:169661] 5<br>2016-03-07 14:45:33.415 GCD[10079:169658] 6<br>2016-03-07 14:45:33.415 GCD[10079:169655] 8<br>2016-03-07 14:45:33.415 GCD[10079:169662] 7</p>
<p>4之后的任务在我线程sleep之后才执行，这其实就起到了一个线程锁的作用，在多个线程同时操作一个对象的时候，读可以放在并发进行，当写的时候，我们就可以用dispatch_barrier_async方法，效果杠杠的。<br>dispatch_sync<br>  ● dispatch_sync 会在当前线程执行队列，并且阻塞当前线程中之后运行的代码，所以，同步线程非常有可能导致死锁现象，我们这边就举一个死锁的例子，直接在主线程调用以下代码：<br>dispatch_sync(dispatch_get_main_queue(), ^{<br>    NSLog(@”有没有同步主线程?”);<br>});</p>
<p>根据FIFO（先进先出）的原则，block里面的代码应该在主线程此次runloop后执行，但是由于他是同步队列，所有他之后的代码会等待其执行完成后才能继续执行，2者相互等待，所以就出现了死锁。<br>我们再举一个比较特殊的例子：</p>
<pre><code>dispatch_queue_t queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_sync(queue, ^{sleep(1);NSLog(@&quot;1&quot;);});
dispatch_sync(queue, ^{sleep(1);NSLog(@&quot;2&quot;);});
dispatch_sync(queue, ^{sleep(1);NSLog(@&quot;3&quot;);});
NSLog(@&quot;4&quot;);
</code></pre><p>其打印结果为：<br>2016-03-07 17:15:48.124 GCD[14198:272683] 1<br>2016-03-07 17:15:49.125 GCD[14198:272683] 2<br>2016-03-07 17:15:50.126 GCD[14198:272683] 3<br>2016-03-07 17:15:50.126 GCD[14198:272683] 4</p>
<p>从线程编号中我们发现，同步方法没有去开新的线程，而是在当前线程中执行队列，会有人问，上文说dispatch_get_global_queue不是并发队列，并发队列不是应该会在开启多个线程吗？这个前提是用异步方法。GCD其实是弱化了线程的管理，强化了队列管理，这使我们理解变得比较形象。</p>
<h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p>这个方法用于无序查找，在一个数组中，我们能开启多个线程来查找所需要的值，我这边也举个例子：</p>
<pre><code>NSArray *array=[[NSArray alloc]initWithObjects:@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;, nil];
dispatch_queue_t queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply([array count], queue, ^(size_t index) {
NSLog(@&quot;%zu=%@&quot;,index,[array objectAtIndex:index]);
});
NSLog(@&quot;阻塞&quot;);
</code></pre><p>输出结果：<br>2016-03-07 17:36:50.726 GCD[14318:291701] 1=1<br>2016-03-07 17:36:50.726 GCD[14318:291705] 0=0<br>2016-03-07 17:36:50.726 GCD[14318:291783] 3=3<br>2016-03-07 17:36:50.726 GCD[14318:291782] 2=2<br>2016-03-07 17:36:50.726 GCD[14318:291784] 5=5<br>2016-03-07 17:36:50.726 GCD[14318:291627] 4=4<br>2016-03-07 17:36:50.726 GCD[14318:291785] 6=6<br>2016-03-07 17:36:50.727 GCD[14318:291627] 阻塞</p>
<p>通过输出log，我们发现这个方法虽然会开启多个线程来遍历这个数组，但是在遍历完成之前会阻塞主线程。</p>
<h4 id="dispatch-suspend-amp-dispatch-resume"><a href="#dispatch-suspend-amp-dispatch-resume" class="headerlink" title="dispatch_suspend &amp; dispatch_resume"></a>dispatch_suspend &amp; dispatch_resume</h4><p>队列挂起和恢复，这个没什么好说的，直接上代码：</p>
<pre><code>dispatch_queue_t concurrentDispatchQueue=dispatch_queue_create(&quot;com.test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(concurrentDispatchQueue, ^{serialDispatchQueue
for (int i=0; i&lt;100; i++)
{
    NSLog(@&quot;%i&quot;,i);
    if (i==50)
    {
        NSLog(@&quot;-----------------------------------&quot;);
        dispatch_suspend(concurrentDispatchQueue);
        sleep(3);
        dispatch_async(dispatch_get_main_queue(), ^{
            dispatch_resume(concurrentDispatchQueue);
        });
    }
}
});
</code></pre><p>我们甚至可以在不同的线程对这个队列进行挂起和恢复，因为GCD是对队列的管理。</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>我们可以通过设置信号量的大小，来解决并发过多导致资源吃紧的情况，以单核CPU做并发为例，一个CPU永远只能干一件事情，那如何同时处理多个事件呢，聪明的内核工程师让CPU干第一件事情，一定时间后停下来，存取进度，干第二件事情以此类推，所以如果开启非常多的线程，单核CPU会变得非常吃力，即使多核CPU，核心数也是有限的，所以合理分配线程，变得至关重要，那么如何发挥多核CPU的性能呢？如果让一个核心模拟传很多线程，经常干一半放下干另一件事情，那效率也会变低，所以我们要合理安排，将单一任务或者一组相关任务并发至全局队列中运算或者将多个不相关的任务或者关联不紧密的任务并发至用户队列中运算，所以用好信号量，合理分配CPU资源，程序也能得到优化，当日常使用中，信号量也许我们只起到了一个计数的作用，真的有点大材小用。</p>
<pre><code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);//为了让一次输出10个，初始信号量为10
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for (int i = 0; i &lt;100; i++)
{
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);//每进来1次，信号量-1;进来10次后就一直hold住，直到信号量大于0；
dispatch_async(queue, ^{
    NSLog(@&quot;%i&quot;,i);
    sleep(2);
    dispatch_semaphore_signal(semaphore);//由于这里只是log,所以处理速度非常快，我就模拟2秒后信号量+1;
});
}
</code></pre><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>这个函数一般是用来做一个真的单例，也是非常常用的，在这里就举一个单例的例子吧：</p>
<pre><code>static SingletonTimer * instance;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
instance = [[SingletonTimer alloc] init];
});

return instance;
</code></pre><p>好了，blog说了这么多关于GCD中的方法，大家是不是觉得这篇blog并没有什么高深的理论，本文更倾向于实用，看完这篇blog之后，大家一定对GCD跃跃欲试了吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- ![](http://ww2.sinaimg.cn/large/006tNbRwgy1ffon7ij0bjj30pw12an0e.jpg) --&gt;
&lt;h3 id=&quot;与其说CGD是线程管理，不如说是队列管理，那么我们先来介绍一下GCD中常用的队列：&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开始一个项目之前的思考</title>
    <link href="http://yoursite.com/2017/05/17/thinkStart/"/>
    <id>http://yoursite.com/2017/05/17/thinkStart/</id>
    <published>2017-05-17T04:35:37.000Z</published>
    <updated>2017-05-17T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1495006385145&amp;di=a0b78ebef4ddb744c8476053e29e8adc&amp;imgtype=0&amp;src=http%3A%2F%2Fimgres.roboo.com%2Fgroup7%2FM00%2FEA%2FFE%2FwKhkDFf_woCAABTgAACqp_qaNtQ458.jpg" alt=""></p>
<h3 id="1-确定编码风格"><a href="#1-确定编码风格" class="headerlink" title="1.确定编码风格"></a>1.确定编码风格</h3><p>风格无对错</p>
<p>OC的<br><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">https://github.com/NYTimes/objective-c-style-guide</a></p>
<p>swift<br><a href="https://github.com/futurice/ios-good-practices" target="_blank" rel="external">https://github.com/futurice/ios-good-practices</a></p>
<h3 id="2-在写代码之前确定应用程序的架构"><a href="#2-在写代码之前确定应用程序的架构" class="headerlink" title="2.在写代码之前确定应用程序的架构"></a>2.在写代码之前确定应用程序的架构</h3><p>是MVC+ 还是MVVM,还是MVP</p>
<h3 id="3-确定应用的目录结构"><a href="#3-确定应用的目录结构" class="headerlink" title="3.确定应用的目录结构"></a>3.确定应用的目录结构</h3><p><img src="http://ww4.sinaimg.cn/large/006tNbRwgy1ffo9jbkxahj30jk04wq33.jpg" alt=""><br>有人说按着架构MVC,MVVM的形式来,有的又说按照模块来<br>个人认为,小的项目按架构来结构清晰,大型的最好还是按模块来<br>这样方便管理</p>
<h3 id="4-三方框架-依赖的管理"><a href="#4-三方框架-依赖的管理" class="headerlink" title="4.三方框架,依赖的管理"></a>4.三方框架,依赖的管理</h3><p>用pod还是carthage<br>CocoaPods的目的是对用户简单，但是Carthage对用户来说是灵活的、不干涉的。<br>不幸的是，Carthage的最大的缺点是—-只支持iOS8及以后版本。</p>
<h3 id="5-确定切换环境的方式"><a href="#5-确定切换环境的方式" class="headerlink" title="5.确定切换环境的方式"></a>5.确定切换环境的方式</h3><p>在企业开发时候不应该直接用生产环境直接进行开发,二十分为开发环境,测试环境,stable环境这样</p>
<h3 id="6-设置合适的证书"><a href="#6-设置合适的证书" class="headerlink" title="6.设置合适的证书"></a>6.设置合适的证书</h3><p>当团队开发时候,不要随便fix issue</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1495006385145&amp;amp;di=a0b78ebef4ddb744c8476053e2
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js简单爬虫</title>
    <link href="http://yoursite.com/2017/05/16/Node-js%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2017/05/16/Node-js简单爬虫/</id>
    <published>2017-05-16T13:22:42.000Z</published>
    <updated>2017-05-19T12:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1494951406852&di=367280f924db4e53682be228cea63f93&imgtype=0&src=http%3A%2F%2Fimg.7xz.com%2Fimg%2Fpicimg%2F201612%2F20161230153304_954cb14589aa8cb8868.jpg) -->
<p>最近在看 Node.js的书,不得不佩服作者的创造力;遂踩着前人的脚印<br>及时充电,手把手教你写一个简单的爬虫;</p>
<h3 id="准备好了吗-撒-一库哟"><a href="#准备好了吗-撒-一库哟" class="headerlink" title="准备好了吗 撒,一库哟"></a>准备好了吗 撒,一库哟</h3><pre><code>cd 到你的Coding 目录下
新建一个文件夹
接着进入这个文件夹中,安装 express
npm install express --registry=https://registry.npm.taobao.org
npm install superagent --save
npm install cheerio --save
touch app.js
</code></pre><h4 id="superagent-和-cheerio是什么"><a href="#superagent-和-cheerio是什么" class="headerlink" title="superagent 和 cheerio是什么?"></a>superagent 和 cheerio是什么?</h4><p>superagent它是一个强大并且可读性很好的轻量级ajaxAPI，<br>是一个关于HTTP方面的一个库，而且它可以将链式写法玩的出神入化。<br>可以理解成一个 Node.js 版的 jquery，<br>用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。</p>
<h5 id="接下来就是在-app-js-中写代码了-准备工作已经完成-比如这里爬取的是-cNodejs-优秀的-node-社区"><a href="#接下来就是在-app-js-中写代码了-准备工作已经完成-比如这里爬取的是-cNodejs-优秀的-node-社区" class="headerlink" title="接下来就是在 app.js 中写代码了,准备工作已经完成,比如这里爬取的是 cNodejs(优秀的 node 社区)"></a>接下来就是在 app.js 中写代码了,准备工作已经完成,比如这里爬取的是 cNodejs(优秀的 node 社区)</h5><pre><code>var express = require(&apos;express&apos;);
var superagent = require(&apos;superagent&apos;);
var cheerio = require(&apos;cheerio&apos;);


var app = express();

app.get(&apos;/&apos;, function(req, res, next) {
 // 用 superagent 去抓取 https://cnodejs.org/ 的内容
superagent.get(&apos;https://cnodejs.org/&apos;)
  .end(function(err, sres) {
    // 常规的错误处理
    if (err) {
      return next(err);
    }
    var items = [];
    // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load，习惯性地命名为 `$`
    // 接下来就可以使用熟悉的 jquery 操作了
    var $ = cheerio.load(sres.text);
    $(&apos;#topic_list .cell&apos;).each(function(index, element) {
      var $img = $(element).find(&apos;img&apos;);
      var $topic = $(element).find(&apos;.topic_title&apos;);
      items.push({
        author: $img.attr(&apos;title&apos;),
        title: $topic.attr(&apos;title&apos;),
        href: $topic.attr(&apos;href&apos;)
      });
    });
    res.send(items);
  });
});

app.listen(3000, function() {
 console.log(&apos;app is listening at port 3000&apos;);
});
</code></pre><h4 id="接着上面的终端里输入-node-app-js"><a href="#接着上面的终端里输入-node-app-js" class="headerlink" title="接着上面的终端里输入 node app.js"></a>接着上面的终端里输入 node app.js</h4><p>然后就可以在<a href="http://localhost:3000中看到抓取的数据了" target="_blank" rel="external">http://localhost:3000中看到抓取的数据了</a><br>如下图所示:<br><img src="http://ww4.sinaimg.cn/large/006tNbRwgy1ffnj88n5d8j30s2122dmg.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494951406852&amp;di=367280f924db4e53682be228cea63f93&amp;imgtype=0&amp;src
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝(勒索蠕虫)修复指南</title>
    <link href="http://yoursite.com/2017/05/15/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D-%E5%8B%92%E7%B4%A2%E8%A0%95%E8%99%AB-%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/05/15/永恒之蓝-勒索蠕虫-修复指南/</id>
    <published>2017-05-15T11:57:46.000Z</published>
    <updated>2017-05-15T12:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494860682820&amp;di=0f1fb4769f245c3ebba2960ff4653627&amp;imgtype=0&amp;src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fw%253D580%2Fsign%3D6e5b3ae0af345982c58ae59a3cf5310b%2F26508435e5dde7116969ed62a5efce1b9c16619a.jpg" alt=""><br>本次威胁主要影响以下操作系统: 桌面版本操作系统:</p>
<pre><code>Windows 2000
Windows XP
Windows Vista
Windows7
Windows8
Windows8.1
Windows10
</code></pre><p>为了确保周一开机时公司电脑和服务器免遭病毒感染或避免更大范围的传播，<br>技术部制定了本文档，用于指导公司小伙伴 根据指南内容进行安全操作。<br>我们选用了 360 勒索蠕虫漏洞修复工具，此修复工具集成免疫、 SMB 服务关闭和各系统下 MS17-010 漏洞检测与修复于一体。<br>可在离线网络环境下一键式修复系统存在的 MS17-010 漏洞，根本解决勒索蠕虫利用 MS17-010 漏洞带来的安全隐患。<br>另外近期网络安全事故频发，Windows 电脑需要安装金山毒霸或者 360 杀毒。</p>
<h4 id="第一步、修复工具及补丁包安装"><a href="#第一步、修复工具及补丁包安装" class="headerlink" title="第一步、修复工具及补丁包安装:"></a>第一步、修复工具及补丁包安装:</h4><p>公司内网下载:点击下载 xxx.zip (公司内网地址)<br>外网下载: 点击下载 <a href="http://down.b.360.cn/EternalBlueFix.zip" target="_blank" rel="external">http://down.b.360.cn/EternalBlueFix.zip</a> 下图为补丁包目录，根据自己系统版本和位数进行选择安装。<br><img src="http://ww3.sinaimg.cn/large/006tKfTcgy1ffmaxcc6djj30oo0iw79x.jpg" alt=""></p>
<h4 id="二、关闭-445-端口操作。"><a href="#二、关闭-445-端口操作。" class="headerlink" title="二、关闭 445 端口操作。"></a>二、关闭 445 端口操作。</h4><p>在 Windows 系统右键点击“我的电脑”，在“服务和应用程序”下的服务项中双击“Server”，<br>在出现的 Server 属性 页面中对“启动类型”选择禁用，并点击“停止”按钮关闭服务。<br>操作成功后，建议重启系统以确保生效。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcgy1ffmazv3zrrj30u00ieted.jpg" alt=""></p>
<h4 id="三、关闭-139-端口操作"><a href="#三、关闭-139-端口操作" class="headerlink" title="三、关闭 139 端口操作"></a>三、关闭 139 端口操作</h4><pre><code>1、右键任务栏网络图标或开打控制面板找到“网络与共享中心”选项;
2、点击“更改适配器设置”;
3、右键本地连接或无线连接的“属性”;
4、打开”Intelnet 协议版本 4(TCP/IPV4)”，可参加下图操作步骤。
最后一定要点击“确定”进行保存操作。
</code></pre><p><img src="http://ww1.sinaimg.cn/large/006tKfTcgy1ffmb2fxbisj31380nkafr.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1494860682820&amp;amp;di=0f1fb4769f245c3ebba2960ff4
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fastlane的使用</title>
    <link href="http://yoursite.com/2017/05/12/fastlane%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/12/fastlane的使用/</id>
    <published>2017-05-12T12:41:51.000Z</published>
    <updated>2017-05-12T14:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对于一个iOS-APP的发布上线，一般来说都需要经历"><a href="#对于一个iOS-APP的发布上线，一般来说都需要经历" class="headerlink" title="对于一个iOS APP的发布上线，一般来说都需要经历:"></a>对于一个iOS APP的发布上线，一般来说都需要经历:</h4><p>编译打包 -&gt; 截图 -&gt; 填写一些说明文字 -&gt; 上传ipa到itunes connect -&gt; 提交供审核。<br>每次都要进行这么多“繁琐”的步骤，对于某些步骤可能一次还不能执行成功需要等着界面提示上传错误然后手动重新再来一次。</p>
<p>在日常开发中，打包也是最后上线不可缺少的环节，如果需要生成ipa文件通常需要在Xcode里<br>点击Product -&gt; Archive，然后在弹出来的Organizer中选择导出什么类型(ad hoc/enterprise)的包。对于大项目来说动辄编译十分钟以上的来说，一天打几个包就差不多过去了。</p>
<p>为了解决这些问题，Felix Krause大神写了一个工具集fastlane。<br>fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android自动化打包和发布.</p>
<p><img src="http://blog.devzeng.com/images/ios-fastlane-in-action/fastlane-logo.png" alt="image"></p>
<h2 id="fastlane-的安装"><a href="#fastlane-的安装" class="headerlink" title="fastlane 的安装"></a>fastlane 的安装</h2><h4 id="1-首先确保安装的-xcode-命令行是最新的"><a href="#1-首先确保安装的-xcode-命令行是最新的" class="headerlink" title="1.首先确保安装的 xcode 命令行是最新的"></a>1.首先确保安装的 xcode 命令行是最新的</h4><p>   如果尚未安装可使用下面命令安装</p>
<pre><code>xcode-select --install
</code></pre><h4 id="2-安装fastlane"><a href="#2-安装fastlane" class="headerlink" title="2.安装fastlane"></a>2.安装fastlane</h4><pre><code>    sudo gem install fastlane
部分人的mac会提示
*ERROR:  While executing gem ... (Errno::EPERM)
               Operation not permitted - /usr/bin/rougify
               *
</code></pre><p>  原因正如提示所说,可以使用下面的命令进行安装</p>
<pre><code>sudo gem install -n /usr/local/bin fastlane
</code></pre><h4 id="当出现如下一大坨时候表示安装成功了"><a href="#当出现如下一大坨时候表示安装成功了" class="headerlink" title="当出现如下一大坨时候表示安装成功了."></a>当出现如下一大坨时候表示安装成功了.</h4><p> <img src="http://ww1.sinaimg.cn/large/006tNbRwgy1ffivh5ki06j30wi0p4gue.jpg" alt=""></p>
<h4 id="3-fastlane组件"><a href="#3-fastlane组件" class="headerlink" title="3.fastlane组件"></a>3.fastlane组件</h4><p> fastlane是一个工具集，包含了我们日常开发中上线时需要的大部分操作。比如gym/deliver等。下面对每个工具进行介绍：</p>
<pre><code>名称    说明
deliver    自动上传截图，APP的元数据，二进制(ipa)文件到iTunes Connect
snapshot    自动截图（基于Xcode7的UI test）
frameit    可以把截的图片自动套上一层外边框
pem    自动生成、更新推送配置文件
 sigh    用来创建、更新、下载、修复Provisioning Profile的工具
 produce    如果你的产品还没在iTunes Connect(iTC)或者Apple Developer Center(ADC)建立，produce可以自动帮你完成这些工作
 cert    自动创建管理iOS代码签名证书
 pilot    管理TestFlight的测试用户，上传二进制文件
 boarding    建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到iTunes Connect(iTC)
gym    自动化编译打包工具
match    证书和配置文件管理工具
scan    自动运行测试工具，并且可以生成漂亮的HTML报告
</code></pre><h4 id="4-fastlane核心概念"><a href="#4-fastlane核心概念" class="headerlink" title="4.fastlane核心概念"></a>4.fastlane核心概念</h4><p>在运行fastlane命令行工具的时候，会读取当前目录下面的fastlane文件夹里面的Fastfile配置文件。里面定义了一个个的lane，下面是官方提供的一个示例：</p>
<pre><code>lane :beta do
increment_build_number
cocoapods
match
testflight
sh &quot;./customScript.sh&quot;
slack
end
</code></pre><p>像<em>increment_build_number</em>、<em>cocoapods</em>这样的一条命令都是一个action，<br>由这样的一个个action组成了一个lane（lane中可以调用其他的lane)。</p>
<h2 id="fastlane实战"><a href="#fastlane实战" class="headerlink" title="fastlane实战"></a>fastlane实战</h2><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><p>在项目的根目录下面，执行fastlane init命令开始初始化。<br>在执行的过程中会要求填写一些项目的资料，如Apple ID等，fastlane会自动检测当前目录下项目的App Name和App Identifier，可以选择自行输入这些信息。初始化完成会在当前目录下面生成一个fastlane的文件夹。</p>
<p><img src="http://blog.devzeng.com/images/ios-fastlane-in-action/fastlane-init.png" alt=""></p>
<p>最重要的两个文件就是Appfile和Fastfile，主要的说明如下：</p>
<p>（1）Appfile里面存放了App的基本信息包括app_identifier、apple_id、team_id等，如果在init的时候输入了正确的apple_id和密码会自动获取team_id。</p>
<p>（2）Fastfile是最重要的一个文件，在这个里面可以编写和定制我们的自动化脚本，所有的流程控制功能都写在这个文件里面。</p>
<p>说明：</p>
<p>（1）如果在init的时候选择了在iTunes Connect创建App，那么fastlane会调用produce进行初始化，如果没有创建后续可以手动执行produce init进行创建。如果没有在初始化的时候选择执行produce流程当然deliver也不会执行，后面可以使用deliver init运行是一样的。</p>
<p>（2）在iTunes Connect中成功创建App之后，fastlane文件夹里面会生成一个Deliverfile的文件。Deliverfile文件主要是deliver的一些配置信息。</p>
<h4 id="2、Fastfile文件"><a href="#2、Fastfile文件" class="headerlink" title="2、Fastfile文件"></a>2、Fastfile文件</h4><p>Fastfile文件的主要结构如下所示：</p>
<pre><code>fastlane_version &quot;2.14.2&quot;
default_platform :ios

platform :ios do
before_all do
       cocoapods
  end

  lane :test do
  end

  lane :beta do
  end

  lane :release do
  end

  after_all do |lane|

  end

  error do |lane, exception|

          end
end
</code></pre><p>说明：</p>
<p>（1）fastlane_version：指定fastlane使用的最小版本<br>（2）default_platform：指定当前默认的平台，可以选择ios/android/mac<br>（3）before_all：在执行每一个lane之前都会调用这部分的内容<br>（4）after_all：在每个lane执行完成之后都会执行这部分的内容<br>（5）error：每个lane执行出错就会执行这部分的内容<br>（6）desc：对lane的描述，fastlane会自动将desc的内容生成说明文档<br>（7）lane：定义一个lane(任务)，可以理解为一个函数，我们在执行的时候使用fastlane [ios] lane名称</p>
<h4 id="3、Fastfile文件的编写"><a href="#3、Fastfile文件的编写" class="headerlink" title="3、Fastfile文件的编写"></a>3、Fastfile文件的编写</h4><pre><code>lane :release do |option|
#根据传入参数version设置app的版本号
increment_version_number(version_number: option[:version])
#自动增加build号
increment_build_number
#证书签名
sigh
#编译打包
scheme_name = option[:scheme]
configuration = &apos;Release&apos;
version = get_info_plist_value(path: &quot;./#{scheme_name}/Info.plist&quot;, key: &quot;CFBundleShortVersionString&quot;)
build = get_info_plist_value(path: &quot;./#{scheme_name}/Info.plist&quot;, key: &quot;CFBundleVersion&quot;)
output_directory = File.expand_path(&quot;..&quot;, Dir.pwd) + File::Separator + &apos;build&apos;
output_name = &quot;#{scheme_name}_#{configuration}_#{version}_#{build}_#{Time.now.strftime(&apos;%Y%m%d%H%M%S&apos;)}.ipa&quot;
gym(scheme: scheme_name, clean: true, export_method:&apos;appstore&apos;, configuration: configuration, output_directory: output_directory, output_name: output_name)
 end
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;对于一个iOS-APP的发布上线，一般来说都需要经历&quot;&gt;&lt;a href=&quot;#对于一个iOS-APP的发布上线，一般来说都需要经历&quot; class=&quot;headerlink&quot; title=&quot;对于一个iOS APP的发布上线，一般来说都需要经历:&quot;&gt;&lt;/a&gt;对于一个iOS
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>惆怅甚至于迷茫</title>
    <link href="http://yoursite.com/2017/05/11/%E8%BF%99%E8%BF%B7%E9%9B%BE%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%86%B2%E7%A0%B4/"/>
    <id>http://yoursite.com/2017/05/11/这迷雾到底怎么冲破/</id>
    <published>2017-05-11T09:05:00.000Z</published>
    <updated>2017-05-12T14:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>想不明白,这是不是也算一种遇人不淑</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想不明白,这是不是也算一种遇人不淑&lt;/p&gt;

    
    </summary>
    
      <category term="意乱情迷" scheme="http://yoursite.com/categories/%E6%84%8F%E4%B9%B1%E6%83%85%E8%BF%B7/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10 Charles 抓 HTTPS 的包的</title>
    <link href="http://yoursite.com/2017/05/11/%E5%AE%89%E5%BE%97%E5%B9%BF%E5%8E%A6%E5%8D%83%E4%B8%87%E9%97%B4/"/>
    <id>http://yoursite.com/2017/05/11/安得广厦千万间/</id>
    <published>2017-05-11T08:50:15.000Z</published>
    <updated>2017-05-12T14:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这里只说与之前不同的地方-不说之前的-mobile-证书安装之类的"><a href="#这里只说与之前不同的地方-不说之前的-mobile-证书安装之类的" class="headerlink" title="这里只说与之前不同的地方,不说之前的 mobile 证书安装之类的:"></a>这里只说与之前不同的地方,不说之前的 mobile 证书安装之类的:</h3><h3 id="当你想-iOS10以下的一样设置完发现还是不能在-iOS10上抓-HTTPS-百感交集啊"><a href="#当你想-iOS10以下的一样设置完发现还是不能在-iOS10上抓-HTTPS-百感交集啊" class="headerlink" title="当你想 iOS10以下的一样设置完发现还是不能在 iOS10上抓 HTTPS 百感交集啊"></a>当你想 iOS10以下的一样设置完发现还是不能在 iOS10上抓 HTTPS 百感交集啊</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><pre><code>来到设置-&gt;关于本机-&gt;证书信任设置
</code></pre><p><img src="http://ww2.sinaimg.cn/large/006tKfTcgy1ffhqmimwyxj309w0hmdgc.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这里只说与之前不同的地方-不说之前的-mobile-证书安装之类的&quot;&gt;&lt;a href=&quot;#这里只说与之前不同的地方-不说之前的-mobile-证书安装之类的&quot; class=&quot;headerlink&quot; title=&quot;这里只说与之前不同的地方,不说之前的 mobile 
    
    </summary>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS 开发" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
