<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="逝殇_Vizard..." type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下接下来我们就聊聊ES6那些可爱的新特性吧1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:  funct">
<meta property="og:type" content="article">
<meta property="og:title" content="学 vue 之前不来了解下 es6？">
<meta property="og:url" content="http://yoursite.com/2018/07/31/学-vue-之前不来了解下-es6？/index.html">
<meta property="og:site_name" content="逝殇_Vizard...">
<meta property="og:description" content="最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下接下来我们就聊聊ES6那些可爱的新特性吧1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:  funct">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/72cd9985gy1ft9l8hv8k6j20qo103wlc.jpg">
<meta property="og:updated_time" content="2018-08-01T09:10:25.495Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学 vue 之前不来了解下 es6？">
<meta name="twitter:description" content="最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下接下来我们就聊聊ES6那些可爱的新特性吧1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:  funct">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/mw690/72cd9985gy1ft9l8hv8k6j20qo103wlc.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/31/学-vue-之前不来了解下-es6？/"/>





  <title>学 vue 之前不来了解下 es6？ | 逝殇_Vizard...</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逝殇_Vizard...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我以为人生很漫长,匆匆翻看,却再也无法逆转</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/学-vue-之前不来了解下-es6？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="_Vizard战国">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=810341348,804739183&fm=23&gp=0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逝殇_Vizard...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学 vue 之前不来了解下 es6？</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T09:35:57+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://wx1.sinaimg.cn/mw690/72cd9985gy1ft9l8hv8k6j20qo103wlc.jpg" alt=""></p>
<h4 id="最近-vue-很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整"><a href="#最近-vue-很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整" class="headerlink" title="最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整"></a>最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整</h4><h4 id="别方丈，来看看吧。虽然-vue-的学习是平滑的但是是建立在你熟悉-es6语法的前提下"><a href="#别方丈，来看看吧。虽然-vue-的学习是平滑的但是是建立在你熟悉-es6语法的前提下" class="headerlink" title="别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下"></a>别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下</h4><h4 id="接下来我们就聊聊ES6那些可爱的新特性吧"><a href="#接下来我们就聊聊ES6那些可爱的新特性吧" class="headerlink" title="接下来我们就聊聊ES6那些可爱的新特性吧"></a>接下来我们就聊聊ES6那些可爱的新特性吧</h4><h3 id="1-变量声明const和let"><a href="#1-变量声明const和let" class="headerlink" title="1.变量声明const和let"></a>1.变量声明const和let</h3><p>在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是<strong>函数变量提升</strong>例如:</p>
<pre><code> function aa() {
if(flag) {
    var test = &apos;hello man&apos;
} else {
    console.log(test)
}
}
</code></pre><p>以上的代码实际上是：</p>
<pre><code>function aa() {
var test // 变量提升，函数最顶部
if(flag) {
    test = &apos;hello man&apos;
} else {
    //此处访问 test 值为 undefined
    console.log(test)
}
//此处访问 test 值为 undefined
  }
</code></pre><h5 id="所以不用关心flag是否为-true-or-false。实际上，无论如何-test-都会被创建声明。"><a href="#所以不用关心flag是否为-true-or-false。实际上，无论如何-test-都会被创建声明。" class="headerlink" title="所以不用关心flag是否为 true or false。实际上，无论如何 test 都会被创建声明。"></a>所以不用关心flag是否为 true or false。实际上，无论如何 test 都会被创建声明。</h5><h4 id="接下来ES6主角登场："><a href="#接下来ES6主角登场：" class="headerlink" title="接下来ES6主角登场："></a>接下来ES6主角登场：</h4><p>我们通常用 let 和 const 来声明，let 表示变量、const 表示常量。let 和 const 都是块级作用域。怎么理解这个块级作用域？</p>
<p><code>在一个函数内部</code></p>
<p><code>在一个代码块内部</code></p>
<pre><code>说白了只要在{}花括号内的代码块即可以认为 let 和 const 的作用域。
</code></pre><p>看下面代码：</p>
<pre><code>function aa() {
if(flag) {
   let test = &apos;hello man&apos;
} else {
    //test 在此处访问不到
    console.log(test)
}
}
</code></pre><p>  let 的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。<br> 再来说说 const<br> const 声明的变量必须提供一个值，而且会被认为是常量，意思就是它的值被设置完成后就不能再修改了。</p>
<pre><code>const name = &apos;lux&apos;
name = &apos;joe&apos; // 再次赋值此时会报错
</code></pre><p>还有，如果 const 的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而变量成员是可以修改的。</p>
<pre><code>const student = { name: &apos;cc&apos; }
// 没毛病
student.name = &apos;yy&apos;
// 如果这样子就会报错了
student  = { name: &apos;yy&apos; }
</code></pre><p>说说TDZ(暂时性死区)，想必你早有耳闻。</p>
<pre><code>{
    console.log(value) // 报错
    let value = &apos;lala&apos;
}
</code></pre><h5 id="我们都知道，JS引擎扫描代码时，如果发现变量声明，用-var-声明变量时会将声明提升到函数或全局作用域的顶部。但是-let-或者-const，会将声明关进一个小黑屋也是TDZ-暂时性死区-，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。"><a href="#我们都知道，JS引擎扫描代码时，如果发现变量声明，用-var-声明变量时会将声明提升到函数或全局作用域的顶部。但是-let-或者-const，会将声明关进一个小黑屋也是TDZ-暂时性死区-，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。" class="headerlink" title="我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。"></a>我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。</h5><p>哦了，说一道面试题</p>
<pre><code>var funcs = []
for (var i = 0; i &lt; 10; i++) {
    funcs.push(function() { console.log(i) })
}
funcs.forEach(function(func) {
    func()
})
</code></pre><p>这样的面试题是大家很常见，很多同学一看就知道输出十次10<br>但是如果我们想依次输出0到9呢？<br>有两种解决方法，直接看一下代码：</p>
<pre><code>    // ES5知识，我们可以利用“立即调用函数”解决这个问题
var funcs = []
for (var i = 0; i &lt; 10; i++) {
    funcs.push(
      (function(value) {
        return function() {
            console.log(value)
        }
    })(i)
  )
}
funcs.forEach(function(func) {
    func()
})

// 再来看看es6怎么处理的
const funcs = []
for (let i = 0; i &lt; 10; i++) {
    funcs.push(function() {
        console.log(i)
    })
}
funcs.forEach(func =&gt; func())
</code></pre><p>达到相同的效果，ES6 简洁的解决方案是不是更让你心动！！！</p>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><p>先聊聊模板字符串😋<br>ES6模板字符简直是开发者的福音啊，解决了 ES5 在字符串功能上的痛点。</p>
<p>第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。</p>
<pre><code> //ES5
var name = &apos;lux&apos;
console.log(&apos;hello&apos; + name)
//es6
const name = &apos;lux&apos;
console.log(`hello ${name}`) //hello lux
</code></pre><p>第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。</p>
<pre><code>// ES5
var msg = &quot;Hi \
man!
&quot;
// ES6
const template = `&lt;div&gt;
    &lt;span&gt;hello world&lt;/span&gt;
&lt;/div&gt;`
</code></pre><p>  对于字符串 ES6+ 当然也提供了很多厉害也很有意思的方法😊 说几个常用的</p>
<pre><code>// 1.includes：判断是否包含然后直接返回布尔值
const str = &apos;hahay&apos;
console.log(str.includes(&apos;y&apos;)) // true

// 2.repeat: 获取字符串重复n次
const str = &apos;he&apos;
console.log(str.repeat(3)) // &apos;hehehe&apos;
//如果你带入小数, Math.floor(num) 来处理
// s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理

// 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束
const str =  &apos;hello world!&apos;
console.log(str.startsWith(&apos;hello&apos;)) // true
console.log(str.endsWith(&apos;!&apos;)) // true

// 4. padStart 和 padEnd 填充字符串，应用场景：时分秒
setInterval(() =&gt; {
    const now = new Date()
    const hours = now.getHours().toString()
    const minutes = now.getMinutes().toString()
    const seconds = now.getSeconds().toString()
    console.log(`${hours.padStart(2, 0)}:${minutes.padStart(2, 0)}:${seconds.padStart(2, 0)}`)
}, 1000)
</code></pre><p>关于模板字符串现在比较常出现的面试题有两道。同学们不妨写试试看？</p>
<p>模拟一个模板字符串的实现。</p>
<pre><code> let address = &apos;北京海淀区&apos;
let name = &apos;lala&apos;
let str = &apos;${name}在${address}上班...&apos;
// 模拟一个方法 myTemplate(str) 最终输出 &apos;lala在北京海淀区上班...&apos;
function myTemplate(str) {
    // try it
}
console.log(myTemplate(str)) // lala在北京海淀区上班...
</code></pre><p>实现标签化模板(自定义模板规则)。</p>
<pre><code> const name = &apos;cc&apos;
const gender = &apos;male&apos;
const hobby = &apos;basketball&apos;
// 实现tag最终输出 &apos;姓名：**cc**，性别：**male**，爱好：**basketball**&apos;
function tag(strings) {
    // do it
}
const str = tag`姓名：${name}，性别：${gender}，爱好：${hobby}`
console.log(str) // &apos;姓名：**cc**，性别：**male**，爱好：**basketball**&apos;
</code></pre><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p>函数默认参数</p>
<p>在ES5我们给函数定义参数默认值是怎么样？</p>
<pre><code>function action(num) {
    num = num || 200
    //当传入num时，num为传入的值
    //当没传入参数时，num即有了默认值200
    return num
}
</code></pre><p>但细心观察的同学们肯定会发现，num传入为0的时候就是false，但是我们实际的需求就是要拿到num = 0，此时num = 200 明显与我们的实际想要的效果明显不一样</p>
<p>ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。</p>
<pre><code>function action(num = 200) {
    console.log(num)
}
action(0) // 0
action() //200
action(300) //300
</code></pre><p>箭头函数</p>
<p>ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。</p>
<p>箭头函数最直观的三个特点。</p>
<p>不需要 function 关键字来创建函数<br>省略 return 关键字<br>继承当前上下文的 this 关键字<br>//例如：</p>
<pre><code>[1,2,3].map(x =&gt; x + 1)
</code></pre><p>//等同于：</p>
<pre><code>     [1,2,3].map((function(x){
    return x + 1
}).bind(this))
</code></pre><p>说个小细节。</p>
<p>当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如:</p>
<pre><code>var people = name =&gt; &apos;hello&apos; + name
//参数name就没有括号
</code></pre><p>作为参考</p>
<pre><code>var people = (name, age) =&gt; {
    const fullName = &apos;hello&apos; + name
    return fullName
}
//如果缺少()或者{}就会报错
</code></pre><p>要不整一道笔试题？哈哈哈哈哈哈哈哈。我不管我先上代码了</p>
<pre><code>// 请使用ES6重构以下代码

var calculate = function(x, y, z) {
  if (typeof x != &apos;number&apos;) { x = 0 }
  if (typeof y != &apos;number&apos;) { y = 6 }

  var dwt = x % y
  var result

  if (dwt == z) { result = true }
  if (dwt != z) { result = false }

  return result
}
const calculate = (x, y, z) =&gt; {
  x = typeof x !== &apos;number&apos; ? 0 : x
  y = typeof y !== &apos;number&apos; ? 6 : y
  return x % y === z
}
</code></pre><h3 id="4-拓展的对象功能"><a href="#4-拓展的对象功能" class="headerlink" title="4.拓展的对象功能"></a>4.拓展的对象功能</h3><p>对象初始化简写</p>
<p>ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：</p>
<pre><code>function people(name, age) {
    return {
        name: name,
        age: age
    };
}
</code></pre><p>键值对重名，ES6可以简写如下：</p>
<pre><code>function people(name, age) {
    return {
        name,
        age
    };
}
</code></pre><p>ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：</p>
<pre><code>const people = {
    name: &apos;lux&apos;,
    getName: function() {
        console.log(this.name)
    }
}
</code></pre><p>ES6通过省略冒号与 function 关键字，将这个语法变得更简洁</p>
<pre><code>const people = {
    name: &apos;lux&apos;,
    getName () {
        console.log(this.name)
    }
}
</code></pre><p>ES6 对象提供了 Object.assign()这个方法来实现浅复制。<br>Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}</p>
<pre><code>const objA = { name: &apos;cc&apos;, age: 18 }
const objB = { address: &apos;beijing&apos; }
const objC = {} // 这个为目标对象
const obj = Object.assign(objC, objA, objB)

// 我们将 objA objB objC obj 分别输出看看
console.log(objA)   // { name: &apos;cc&apos;, age: 18 }
console.log(objB) // { address: &apos;beijing&apos; }
console.log(objC) // { name: &apos;cc&apos;, age: 18, address: &apos;beijing&apos; }
console.log(obj) // { name: &apos;cc&apos;, age: 18, address: &apos;beijing&apos; }

// 是的，目标对象ObjC的值被改变了。
// so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象{}
Object.assign({}, objC, objA, objB)
</code></pre><h3 id="5-更方便的数据访问–解构"><a href="#5-更方便的数据访问–解构" class="headerlink" title="5.更方便的数据访问–解构"></a>5.更方便的数据访问–解构</h3><p>数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程</p>
<p>ES5我们提取对象中的信息形式如下：</p>
<pre><code>const people = {
    name: &apos;lux&apos;,
    age: 20
}
const name = people.name
const age = people.age
console.log(name + &apos; --- &apos; + age)
</code></pre><p>是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如</p>
<pre><code>//对象
const people = {
    name: &apos;lux&apos;,
    age: 20
}
const { name, age } = people
console.log(`${name} --- ${age}`)
//数组
const color = [&apos;red&apos;, &apos;blue&apos;]
const [first, second] = color
console.log(first) //&apos;red&apos;
console.log(second) //&apos;blue&apos;
</code></pre><p>要不来点儿面试题，看看自己的掌握情况？</p>
<pre><code>// 请使用 ES6 重构一下代码

// 第一题
var jsonParse = require(&apos;body-parser&apos;).jsonParse

// 第二题
var body = request.body
var username = body.username
var password = body.password

// 1.
import { jsonParse } from &apos;body-parser&apos;
// 2.
const { body, body: { username, password } } = request
</code></pre><h3 id="6-Spread-Operator-展开运算符"><a href="#6-Spread-Operator-展开运算符" class="headerlink" title="6.Spread Operator 展开运算符"></a>6.Spread Operator 展开运算符</h3><p>ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。</p>
<p>组装对象或者数组</p>
<pre><code>//数组
const color = [&apos;red&apos;, &apos;yellow&apos;]
const colorful = [...color, &apos;green&apos;, &apos;pink&apos;]
console.log(colorful) //[red, yellow, green, pink]

//对象
const alp = { fist: &apos;a&apos;, second: &apos;b&apos;}
const alphabets = { ...alp, third: &apos;c&apos; }
console.log(alphabets) //{ &quot;fist&quot;: &quot;a&quot;, &quot;second&quot;: &quot;b&quot;, &quot;third&quot;: &quot;c&quot;
</code></pre><p>}<br>有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项</p>
<pre><code>//数组
const number = [1,2,3,4,5]
const [first, ...rest] = number
console.log(rest) //2,3,4,5
//对象
const user = {
    username: &apos;lux&apos;,
    gender: &apos;female&apos;,
    age: 19,
    address: &apos;peking&apos;
}
const { username, ...rest } = user
console.log(rest) //{&quot;address&quot;: &quot;peking&quot;, &quot;age&quot;: 19, &quot;gender&quot;: &quot;female&quot;
</code></pre><p>}<br>对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边</p>
<pre><code>const first = {
    a: 1,
    b: 2,
    c: 6,
}
const second = {
    c: 3,
    d: 4
}
const total = { ...first, ...second }
console.log(total) // { a: 1, b: 2, c: 3, d: 4 }
</code></pre><h3 id="7-import-和-export"><a href="#7-import-和-export" class="headerlink" title="7.import 和 export"></a>7.import 和 export</h3><p>import导入模块、export导出模块</p>
<pre><code>    //全部导入
    import people from &apos;./example&apos;

    //有一种特殊情况，即允许你将整个模块当作单一对象进行导入
    //该模块的所有导出都会作为对象的属性存在
    import * as example from &quot;./example.js&quot;
    console.log(example.name)
    console.log(example.age)
    console.log(example.getName())

    //导入部分
    import {name, age} from &apos;./example&apos;

// 导出默认, 有且只有一个默认
export default App

// 部分导出
export class App extend Component {};
</code></pre><h4 id="以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结："><a href="#以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：" class="headerlink" title="以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结："></a>以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：</h4><pre><code>1.当用export default people导出时，就用 import people 导入（不带大括号）

2.一个文件里，有且只能有一个export default。但可以有多个export。

3.当用export name 时，就用import { name }导入（记得带上大括号）

4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age }

5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example
</code></pre><h2 id="8-Promise"><a href="#8-Promise" class="headerlink" title="8. Promise"></a>8. Promise</h2><p>在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。<br>说白了就是用同步的方式去写异步代码。</p>
<p>发起异步请求</p>
<pre><code>fetch(&apos;/api/todos&apos;)
  .then(res =&gt; res.json())
  .then(data =&gt; ({ data }))
  .catch(err =&gt; ({ err }));
</code></pre><p>今天看到一篇关于面试题的很有意思。</p>
<pre><code>setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for( var i=0 ; i&lt;10000 ; i++ ) {
    i == 9999 &amp;&amp; resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
</code></pre><p>Excuse me？这个前端面试在搞事！</p>
<p>当然以上promise的知识点，这个只是冰山一角。需要更多地去学习了解一下。</p>
<h3 id="9-Generators"><a href="#9-Generators" class="headerlink" title="9.Generators"></a>9.Generators</h3><p>生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</p>
<p>这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。</p>
<p>OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。</p>
<pre><code>// 生成器
function *createIterator() {
    yield 1;
    yield 2;
    yield 3;
}

// 生成器能像正规函数那样被调用，但会返回一个迭代器
let iterator = createIterator();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
</code></pre><p>那生成器和迭代器又有什么用处呢？</p>
<p>围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。</p>
<p>生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。</p>
<p>那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的</p>
<pre><code>function run(taskDef) { //taskDef即一个生成器函数

    // 创建迭代器，让它在别处可用
    let task = taskDef();

    // 启动任务
    let result = task.next();

    // 递归使用函数来保持对 next() 的调用
    function step() {

        // 如果还有更多要做的
        if (!result.done) {
            result = task.next();
            step();
        }
    }

    // 开始处理过程
    step();

}
</code></pre><p>生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。<br>总结</p>
<p>ES6新特性远不止于此，但对于我们日常的开发来说。这算不上全部，但是能算得上是高频使用了。当然还有很有好玩有意思的特性。比如一些数组的新方法、class…等等。包括用set处理数组去重问题等等。我和我的小伙伴们都惊呆了!</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/21/vue-初体验/" rel="next" title="vue 初体验">
                <i class="fa fa-chevron-left"></i> vue 初体验
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/05/WX-small-app的反编译探究/" rel="prev" title="WX_small_app的反编译探究">
                WX_small_app的反编译探究 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=810341348,804739183&fm=23&gp=0.jpg"
               alt="_Vizard战国" />
          <p class="site-author-name" itemprop="name">_Vizard战国</p>
           
              <p class="site-description motion-element" itemprop="description">我以为人生很漫长,匆匆翻看,却再也无法逆转</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/easyzhan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2284402457/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#最近-vue-很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整"><span class="nav-number">1.</span> <span class="nav-text">最近 vue 很火，是不是准备开始学习了？但是你会发现有一些语法不懂，这可咋整</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#别方丈，来看看吧。虽然-vue-的学习是平滑的但是是建立在你熟悉-es6语法的前提下"><span class="nav-number">2.</span> <span class="nav-text">别方丈，来看看吧。虽然 vue 的学习是平滑的但是是建立在你熟悉 es6语法的前提下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接下来我们就聊聊ES6那些可爱的新特性吧"><span class="nav-number">3.</span> <span class="nav-text">接下来我们就聊聊ES6那些可爱的新特性吧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-变量声明const和let"><span class="nav-number"></span> <span class="nav-text">1.变量声明const和let</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#所以不用关心flag是否为-true-or-false。实际上，无论如何-test-都会被创建声明。"><span class="nav-number">0.1.</span> <span class="nav-text">所以不用关心flag是否为 true or false。实际上，无论如何 test 都会被创建声明。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接下来ES6主角登场："><span class="nav-number">1.</span> <span class="nav-text">接下来ES6主角登场：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#我们都知道，JS引擎扫描代码时，如果发现变量声明，用-var-声明变量时会将声明提升到函数或全局作用域的顶部。但是-let-或者-const，会将声明关进一个小黑屋也是TDZ-暂时性死区-，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。"><span class="nav-number">1.1.</span> <span class="nav-text">我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-字符串"><span class="nav-number"></span> <span class="nav-text">2.字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-函数"><span class="nav-number"></span> <span class="nav-text">3.函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-拓展的对象功能"><span class="nav-number"></span> <span class="nav-text">4.拓展的对象功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-更方便的数据访问–解构"><span class="nav-number"></span> <span class="nav-text">5.更方便的数据访问–解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Spread-Operator-展开运算符"><span class="nav-number"></span> <span class="nav-text">6.Spread Operator 展开运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-import-和-export"><span class="nav-number"></span> <span class="nav-text">7.import 和 export</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结："><span class="nav-number">1.</span> <span class="nav-text">以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Promise"><span class="nav-number"></span> <span class="nav-text">8. Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Generators"><span class="nav-number"></span> <span class="nav-text">9.Generators</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_Vizard战国</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
